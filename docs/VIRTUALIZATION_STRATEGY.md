# استراتيجية Virtualization في المشروع

بناءً على أن القوائم الحالية تعمل بـ **render كامل لكل العناصر داخل scroll container واحد** (بدون RecyclerView/virtualization)، هذا الملف يحدد:
1. أين نُدخل virtualization أولاً (الأكثر تأثيراً على الأداء).
2. من أين نبدأ ليكون النظام موحداً وبدون كود صلب.

---

## 1. أولوية إدخال Virtualization (من الأكثر تأثيراً)

| الترتيب | المكان | المكوّن / الصفحة | السبب التقني |
|--------|--------|-------------------|---------------|
| **1** | **تاب الفيديوهات (الرئيسية)** | `VideoShortsFeed` + `useUnifiedVideoFeed` | قائمة طويلة تتراكم (infinite scroll بـ PAGE_SIZE=20)، كل عنصر ثقيل (فيديو/ثامبنيل)، وكل العناصر مُرسمة في الـ DOM. التأثير على الذاكرة ووقت الرسم أعلى من باقي القوائم. |
| **2** | **الصفحة الرئيسية — تاب المنشورات/المنتجات** | `app/page.tsx` + `items.map` + `BanCard` | نفس الفكرة: infinite scroll، عناصر ثقيلة (صور/كروت)، تراكم العناصر مع التمرير. |
| **3** | **صفحة الأماكن** | `app/places/page.tsx` + `filteredPlaces.map` | تحميل كل الأماكن دفعة واحدة (`usePlaces` بدون pagination)، شبكة كروت مع صور. يمكن أن تكبر القائمة مع الوقت. |
| **4** | **صفحة تفاصيل المكان — تاب المنشورات والمنتجات** | `app/places/[id]/page.tsx` + `posts.map` / `products.map` | قائمتان طويلتان على نفس الصفحة، منشورات قد تحتوي صور/فيديو، منتجات مع صور. |
| **5** | **صفحة المحادثات** | `app/messages/page.tsx` + `conversations.map` / `placesWithRoleFiltered.map` | عدد العناصر عادةً صغير (عشرات)، أولوية أقل من الفيديوهات والفييد الموحد. |

**الخلاصة:** أول مكان يُستحسن إدخال virtualization فيه هو **VideoShortsFeed** (تاب الفيديوهات)، ثم الصفحة الرئيسية (فييد المنشورات/المنتجات)، ثم صفحة الأماكن، ثم صفحة تفاصيل المكان، وأخيراً المحادثات إذا دعت الحاجة.

---

## 2. كيف نبدأ بشكل موحد وبدون كود صلب

الفكرة: **لا نكتب virtualization مكرر في كل صفحة**، بل نعتمد على طبقة موحدة واحدة ثم نستخدمها في كل القوائم.

### 2.1 طبقة موحدة واحدة

- **مكتبة مقترحة:** `@tanstack/react-virtual` (خفيفة، headless، تعمل مع أي scroll container وتدعم قوائم وع grids).
- **مكوّن مشترك:** مكوّن واحد في المشروع (مثلاً `VirtualList` أو `VirtualizedList`) داخل `components/common/`:
  - يستقبل: `items`, `renderItem`, `estimateSize` (أو `itemSize` ثابت)، واختيارياً `scrollRef` للحاوية.
  - يستخدم `useVirtualizer` داخلياً.
  - يلتزم بالثيم (مثلاً `useTheme`) وأي اتفاقيات واجهة موجودة (مثل M3 إن لزم).
- **هوك اختياري:** إذا احتجنا نفس المنطق في أكثر من مكان، نستخرج هوكاً مثل `useVirtualList(items, options)` يرجع `virtualItems` وخصائص الحاوية، والمكوّن المشترك يستخدم هذا الهوك داخله حتى لا يتكرر المنطق.

بهذا يكون كل استعمال virtualization في المشروع عبر نفس المكوّن/الهوك، فلا كود virtualization مكتوب يدوياً في كل صفحة.

### 2.2 خطوات التطبيق المقترحة

1. **إضافة التبعية:**  
   `npm i @tanstack/react-virtual`
2. **إنشاء المكوّن الموحد:**  
   - ملف مثل: `components/common/VirtualList.tsx` (أو الاسم المتفق عليه في المشروع).  
   - واجهة واضحة: `items`, `renderItem`, `estimateSize` أو `itemSize`, واختيارياً `scrollRef`, `overscan`.  
   - لا hardcode لاحتياجات صفحة واحدة؛ المكوّن يعرض «قائمة افتراضية» فقط.
3. **أول استخدام:**  
   استبدال عرض القائمة في **VideoShortsFeed** باستخدام هذا المكوّن (أو استخدام `useVirtualizer` داخل `VideoShortsFeed` مع الاستعانة بنفس الهوك/المكوّن الموحد). التأكد أن infinite scroll (تحميل الصفحة التالية) يعمل مع الـ virtualizer (مثلاً باستخدام sentinel أو قياس نهاية العناصر المرئية).
4. **توثيق في النظام الموحد:**  
   إضافة فقرة في `UNIFIED_SYSTEM_REFERENCE.md` (أو في هذا الملف والإشارة منه):  
   - متى نستخدم قائمة افتراضية: قوائم طويلة أو عناصر ثقيلة.  
   - أن القوائم الافتراضية تُبنى عبر المكوّن/الهوك الموحد فقط، وعدم تكرار منطق الـ virtualization في الصفحات.
5. **باقي القوائم:**  
   بعد استقرار VideoShortsFeed، نطبق نفس المكوّن/الهوك على الصفحة الرئيسية ثم الأماكن ثم تفاصيل المكان حسب الجدول أعلاه.

### 2.3 ما يُجنّبه هذا النهج

- عدم كتابة `useVirtualizer` أو منطق virtualization مباشرة في كل صفحة (لا كود صلب مكرر).
- عدم اختيار مكتبات أو أنماط مختلفة لكل قائمة؛ طبقة واحدة = سلوك واحد وسهل الصيانة.

---

## 3. ما تم تطبيقه

| الأولوية | المكان | الحالة |
|----------|--------|--------|
| 1 | **VideoShortsFeed** (تاب الفيديوهات) | ✅ VirtualList — صفوف × 2، حاوية تمرير محلية (`gridContainerRef`) |
| 2 | **FeedPanel** (تاب المنشورات/المنتجات — الصفحة الرئيسية) | ✅ VirtualList — منشورات (قائمة)، منتجات (صفوف × 3)، حاوية التمرير من `useScrollContainer()` |
| 3 | **صفحة الأماكن** (`app/places/page.tsx`) | ✅ VirtualList — قائمة أماكن، حاوية التمرير من `useScrollContainer()` |
| 4 | **صفحة تفاصيل المكان** (`app/places/[id]/page.tsx`) — تاب المنشورات والمنتجات | ✅ VirtualList — منشورات (قائمة)، منتجات (صفوف × 3)، حاوية التمرير من `useScrollContainer()`؛ أزرار حذف M3، مسافات `gap-element` و `rounded-section` و `p-main` |
| 5 | **صفحة المحادثات** (`app/messages/page.tsx`) + **داخل المحادثة** (`MessagesInlineChat`) | ✅ VirtualList — قائمة المحادثات، شبكة الأماكن (صفوف × 2)، حاوية التمرير من `useScrollContainer()`؛ داخل المحادثة: قائمة الرسائل واختيار المنتج بحاوية تمرير محلية؛ مسافات `gap-element` و `rounded-section` و `p-main` |
| 6 | **التعليقات** (`components/common/Comments.tsx`) | ✅ VirtualList — قائمة التعليقات (تعليق رئيسي + ردوده) بحاوية تمرير محلية (`commentsListRef`، `maxHeight`)؛ مسافات `gap-element` و `rounded-section` و `p-main`؛ التعليق المتفائل (Optimistic) يظهر بعد القائمة الافتراضية |

**حاوية التمرير:** في الصفحات داخل AppShell، مرجع التمرير هو الـ `main` (من `ScrollContainerContext`). استخدم `useScrollContainer()` من `@/contexts/ScrollContainerContext` لتمريره إلى `VirtualList` كـ `scrollElementRef`. في المكوّنات التي لها حاوية تمرير خاصة (مثل VideoShortsFeed)، استخدم `useRef` محلياً.

---

## 4. ملخص سريع

- **أول مكان يُدخل فيه virtualization:** تاب الفيديوهات (`VideoShortsFeed`) لأنه الأكثر تأثيراً على الأداء (قائمة طويلة + عناصر ثقيلة + تراكم مع infinite scroll).
- **كيف نبقى موحدين وبدون كود صلب:** الاعتماد على مكوّن/هوك واحد (مثل `VirtualList` + `@tanstack/react-virtual`) في `components/common`، وحاوية تمرير موحدة عبر `useScrollContainer()` عند الحاجة، وتوثيق الاستخدام في مرجع النظام الموحد.
